1. Сортировка выбором
Задача 1: Напишите функцию, которая принимает массив целых чисел и сортирует его с помощью алгоритма сортировки выбором. Однако, если массив содержит дубликаты, они должны быть 
сгруппированы вместе. Например, для входного массива [64, 25, 25, 12, 22, 11] результат должен быть [11, 12, 22, 25, 25, 64].
Задача 2: Реализуйте сортировку выбором для массива строк, но добавьте условие, что строки должны быть отсортированы по длине, а затем по алфавиту. Например, для входного массива 
["banana", "apple", "kiwi", "cherry"] результат должен быть ["kiwi", "apple", "banana", "cherry"].

2. Массивы и связанные списки
Задача 1: Создайте класс для связанного списка и реализуйте методы для добавления элемента в конец списка, удаления элемента и поиска элемента по значению. Дополнительно добавьте 
метод, который возвращает количество элементов в списке и метод, который разворачивает список.
Задача 2: Напишите функцию, которая принимает массив чисел и возвращает связанный список, содержащий те же числа, а также добавьте метод, который находит среднее значение всех 
элементов списка.

3. Рекурсия
Задача 1: Напишите рекурсивную функцию, которая вычисляет ( n )-й член последовательности Фибоначчи, используя мемоизацию для оптимизации. Например, для ( n = 50 ) результат должен 
быть 12586269025.
Задача 2: Реализуйте рекурсивную функцию для вычисления суммы всех элементов массива, но добавьте условие, что если элемент отрицательный, он не учитывается в сумме. Например, для 
входного массива [1, -2, 3, 4] результат должен быть 8.

4. Стек
Задача 1: Реализуйте стек с операциями push, pop, peek и is_empty. Добавьте метод, который возвращает минимальный элемент в стеке за ( O(1) ). Например, если стек содержит элементы 
[3, 5, 2, 1], метод должен вернуть 1.
Задача 2: Напишите программу, которая проверяет, является ли строка с круглой скобкой сбалансированной. Усложните задачу, добавив поддержку квадратных и фигурных скобок. Например, 
строка "{[()()]}" должна вернуть true, а "{[(])}" — false.

5. Поиск в ширину
Задача 1: Реализуйте алгоритм поиска в ширину для нахождения кратчайшего пути в графе, представленном в виде списка смежности. Усложните задачу, добавив веса к ребрам и возвращая 
не только путь, но и его стоимость. Например, для графа с вершинами A, B, C, D и ребрами с весами, определите кратчайший путь от A до D и его сумму весов.
Задача 2: Напишите программу, которая находит все вершины, достижимые из заданной вершины в неориентированном графе, но добавьте условие, что некоторые вершины могут быть недоступны 
(например, заблокированы). Например, если граф имеет вершины A, B, C, D и заблокирована вершина C, программа должна вернуть только достижимые вершины от A (например, B и D).

6. Пузырьковая сортировка
Задача 1: Реализуйте пузырьковую сортировку для массива целых чисел. Например, для входного массива [5, 3, 8, 4, 2] результат должен быть [2, 3, 4, 5, 8].
Задача 2: Напишите функцию, которая сортирует массив строк в порядке убывания. Например, для входного массива ["pear", "apple", "orange"] результат должен быть 
["pear", "orange", "apple"].

7. Бинарный поиск
Задача 1: Напишите функцию, которая выполняет бинарный поиск в отсортированном массиве. Например, для массива [1, 2, 3, 4, 5] и искомого элемента 3 результат должен быть 2 (индекс).
Задача 2: Реализуйте бинарный поиск, который возвращает -1, если элемент не найден. Например, для массива [10, 20, 30] и искомого элемента 25 результат должен быть -1.

8. Алгоритм Дейкстра
Задача 1: Реализуйте алгоритм Дейкстра для нахождения кратчайшего пути в графе с положительными весами. Например, для графа с вершинами A, B, C и ребрами с весами, определите 
кратчайший путь от A до C.
Задача 2: Напишите программу, которая, используя алгоритм Дейкстра, находит кратчайшие расстояния от одной вершины до всех остальных в графе.

9. Задача составления расписания
Задача 1: Напишите программу, которая принимает список задач с временными интервалами (например, [ (1, 3), (2, 5), (4, 6) ]) и возвращает максимальное количество задач, 
которые можно выполнить без перекрытия.
Задача 2: Реализуйте алгоритм, который находит оптимальное расписание для заданного набора задач с учетом их длительности и временных ограничений.

10. Задача о рюкзаке
Задача 1: Напишите программу, которая решает задачу о рюкзаке с использованием динамического программирования. У вас есть предметы с заданными весами и ценами, 
и рюкзак с ограниченной вместимостью.
Задача 2: Реализуйте жадный алгоритм для решения задачи о рюкзаке, где предметы могут быть разрезаны (например, задача о дробном рюкзаке).

11. Приближенные алгоритмы
Задача 1: Напишите приближенный алгоритм для задачи о коммивояжере, который находит решение, близкое к оптимальному, используя жадный подход.
Задача 2: Реализуйте алгоритм, который использует метод локального поиска для приближенного решения задачи о коммивояжере.

12. Алгоритм K ближайших соседей
Задача 1: Напишите реализацию алгоритма K ближайших соседей для классификации точек в двумерном пространстве. Например, определите класс точки на основании 
ее K ближайших соседей.
Задача 2: Реализуйте KNN для регрессии, где необходимо предсказать значение на основе K ближайших соседей.

13. Деревья
Задача 1: Создайте бинарное дерево поиска и реализуйте функции для вставки и удаления узлов. Напишите функцию, которая возвращает элементы дерева в порядке возрастания.
Задача 2: Реализуйте алгоритм обхода бинарного дерева (прямой, симметричный и посторочный) и напишите тесты для проверки правильности работы.
